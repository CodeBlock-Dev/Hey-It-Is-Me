@using Microsoft.JSInterop
@using System.Threading

<div class="wizard-step">
    <div class="text-center mb-4">
        <i class="bi bi-image text-primary" style="font-size: 2.5rem;"></i>
        <h3 class="mt-3 mb-3">Add a Reference Image</h3>
        <p class="text-muted">Help AI understand your appearance to generate more accurate personalized images</p>
    </div>
    
    <div class="form-group mb-4">
        <label class="form-label fw-bold">Reference Image</label>
        <InputFile OnChange="@OnReferenceFileSelected" accept="image/*" class="form-control" />
        @if (ReferencePreview != null)
        {
            <div class="mt-3">
                <img src="@ReferencePreview" alt="Reference preview" style="max-width: 200px; max-height: 200px; border-radius: 8px;" />
            </div>
        }
        <div class="form-text">
            <i class="bi bi-info-circle me-1"></i>
            <strong>Important:</strong> Please upload a full body picture showing your complete appearance (not just your face). This helps AI understand your height, body type, style, and overall look to generate personalized images for your facts. A well-lit, full-body photo where you're clearly visible works best.
        </div>
    </div>
    
    <div class="d-flex justify-content-end">
        <button class="btn btn-primary" @onclick="HandleUpdateReferenceImage" disabled="@IsLoading">
            @if (IsLoading)
            {
                <span class="spinner-border spinner-border-sm me-2"></span>
            }
            else
            {
                <i class="bi bi-check-lg me-2"></i>
            }
            Continue
        </button>
    </div>
</div>

@if (ShowCropper)
{
    <div class="image-cropper-modal" @onclick="HandleBackdropClick">
        <div class="image-cropper-content" @onclick:stopPropagation="true">
            <div class="image-cropper-header">
                <h4>Crop Your Image</h4>
                <p class="text-muted mb-0">Drag the image to position it within the 1:1 crop area</p>
            </div>
            
            <div class="image-cropper-container" id="@ContainerId">
                <img id="@ImageId" class="image-cropper-image" src="@SelectedImageDataUrl" alt="Crop preview" />
                <div class="image-cropper-crop-box" id="@CropBoxId"></div>
            </div>
            
            <div class="image-cropper-actions">
                <button class="btn btn-outline-secondary" @onclick="HandleCropCancel" disabled="@IsProcessing">
                    Cancel
                </button>
                <button class="btn btn-primary" @onclick="HandleCrop" disabled="@IsProcessing">
                    @if (IsProcessing)
                    {
                        <span class="spinner-border spinner-border-sm me-2"></span>
                    }
                    <i class="bi bi-check-lg me-2"></i>
                    Apply Crop
                </button>
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public string PageId { get; set; }
    [Parameter] public EventCallback OnNext { get; set; }
    
    [Inject] private IJSRuntime JSRuntime { get; set; }
    
    private string ReferenceBase64;
    private string ReferencePreview;
    private bool IsLoading = false;
    private bool ShowCropper = false;
    private string SelectedImageDataUrl;
    private string SelectedImageContentType;
    
    // ImageCropper fields
    private string ContainerId = $"cropper-container-{Guid.NewGuid():N}";
    private string ImageId = $"cropper-image-{Guid.NewGuid():N}";
    private string CropBoxId = $"cropper-box-{Guid.NewGuid():N}";
    private bool IsProcessing = false;
    private bool IsInitialized = false;
    private string PreviousImageDataUrl;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ShowCropper && !string.IsNullOrEmpty(SelectedImageDataUrl))
        {
            // Check if image changed or needs initialization
            if (!IsInitialized || PreviousImageDataUrl != SelectedImageDataUrl)
            {
                // Small delay to ensure DOM is ready
                await Task.Delay(50);
                await JSRuntime.InvokeVoidAsync("imageCropper.initialize", SelectedImageDataUrl, ContainerId, ImageId, CropBoxId);
                IsInitialized = true;
                PreviousImageDataUrl = SelectedImageDataUrl;
            }
        }
        else if (!ShowCropper && IsInitialized)
        {
            // Reset when cropper is hidden
            IsInitialized = false;
            PreviousImageDataUrl = null;
            await JSRuntime.InvokeVoidAsync("imageCropper.reset");
        }
    }
    
    private async Task OnReferenceFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            // Validate file size (max 10MB)
            if (file.Size > 10 * 1024 * 1024)
            {
                return;
            }

            // Validate file type
            if (!file.ContentType.StartsWith("image/"))
            {
                return;
            }

            // Convert to base64 for cropper
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var imageBytes = memoryStream.ToArray();
            var base64 = Convert.ToBase64String(imageBytes);
            
            // Store image data for cropper
            SelectedImageDataUrl = $"data:{file.ContentType};base64,{base64}";
            SelectedImageContentType = file.ContentType;
            ShowCropper = true;
            
            StateHasChanged();
        }
    }
    
    private async Task HandleCrop()
    {
        IsProcessing = true;
        StateHasChanged();

        try
        {
            // --- Wait for cropper readiness ---
            var maxWaitTime = DateTime.UtcNow.AddSeconds(5);
            bool isReady = false;
            int attempts = 0;

            while (DateTime.UtcNow < maxWaitTime && !isReady && attempts < 50)
            {
                try
                {
                    isReady = await JSRuntime.InvokeAsync<bool>("imageCropper.checkReady");
                    if (isReady)
                        break;
                }
                catch (JSException)
                {
                    // Continue retrying
                }

                await Task.Delay(100);
                attempts++;
            }

            if (!isReady)
                throw new Exception("Cropper not ready after waiting");

            // --- Call JS and receive Blob as stream ---
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20));

            var streamRef = await JSRuntime.InvokeAsync<IJSStreamReference>(
                "imageCropper.getCroppedImage",
                cts.Token
            );

            if (streamRef is null)
                throw new Exception("Failed to receive image stream from JS");

            await using var stream = await streamRef.OpenReadStreamAsync(
                maxAllowedSize: 2 * 1024 * 1024, // 2MB safety cap
                cancellationToken: cts.Token
            );

            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms, cts.Token);

            var imageBytes = ms.ToArray();

            if (imageBytes.Length == 0)
                throw new Exception("Cropped image stream was empty");

            // --- Convert to Base64 (only on server side) ---
            ReferenceBase64 = Convert.ToBase64String(imageBytes);

            // --- Preview (JPEG enforced by cropper) ---
            ReferencePreview = $"data:image/jpeg;base64,{ReferenceBase64}";

            // --- UI cleanup ---
            ShowCropper = false;
            SelectedImageDataUrl = null;

            await JSRuntime.InvokeVoidAsync("imageCropper.reset");
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    
    private async Task HandleCropCancel()
    {
        await JSRuntime.InvokeVoidAsync("imageCropper.reset");
        ShowCropper = false;
        SelectedImageDataUrl = null;
        StateHasChanged();
    }
    
    private async Task HandleBackdropClick()
    {
        await HandleCropCancel();
    }
    
    private async Task HandleUpdateReferenceImage()
    {
        if (ReferenceBase64 == null || string.IsNullOrWhiteSpace(PageId))
            return;
            
        IsLoading = true;
        var result = await PageService.UpdatePageReferenceImage(PageId, ReferenceBase64);
        if (result.IsSuccess)
        {
            // Update page state to next step in wizard
            var stateResult = await PageService.UpdatePageState(PageId, Core.Domain.Pages.PageState.PendingQuestions);
            if (!stateResult.IsSuccess)
            {
                stateResult.ShowErrorToast(ToastService);
            }
            else
            {
                await OnNext.InvokeAsync();
            }
        }
        else
        {
            result.ShowErrorToast(ToastService);
        }
        IsLoading = false;
    }
}
